<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API-Enabled DNA-Silver Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            padding: 30px;
        }
        
        .input-panel {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #e2e8f0;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }
        
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .file-upload {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }
        
        .file-upload input[type=file] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-upload-label {
            display: block;
            padding: 12px;
            background: #f1f5f9;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            text-align: center;
            color: #64748b;
        }
        
        .btn {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        
        .results-panel {
            background: white;
            border-radius: 15px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }
        
        .results-content {
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .status {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }
        
        .status.info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }
        
        .status.success {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #86efac;
        }
        
        .status.error {
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fca5a5;
        }
        
        .status.warning {
            background: #fef3c7;
            color: #d97706;
            border: 1px solid #fcd34d;
        }
        
        .deployment-options {
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            border: 2px solid #0284c7;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .deployment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .deployment-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .api-status {
            background: #f0f9ff;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .plot-container {
            margin: 20px 0;
            height: 500px;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 12px;
        }
        
        .data-table th,
        .data-table td {
            padding: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }
        
        .data-table th {
            background: #f1f5f9;
            font-weight: 600;
        }
        
        .fallback-storage {
            background: #fffbeb;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê API-Enabled DNA-Silver Analyzer</h1>
            <p>Full API access + Multiple deployment options to fix IndexedDB issues</p>
        </div>
        
        <div class="main-content">
            <div class="input-panel">
                <h3>üì• Input Data</h3>
                
                <div class="api-status" id="apiStatus">
                    <h4>üîß API Status Check</h4>
                    <p id="statusText">Checking API availability...</p>
                </div>
                
                <div class="form-group">
                    <label for="dnaSequence">DNA Sequence:</label>
                    <textarea id="dnaSequence" rows="3" placeholder="Enter DNA sequence">CACCTAGCG</textarea>
                </div>
                
                <div class="form-group">
                    <label for="emissionColor">Emission Color:</label>
                    <select id="emissionColor">
                        <option value="green">üü¢ Green (&lt;590 nm)</option>
                        <option value="red" selected>üî¥ Red (590-660 nm)</option>
                        <option value="fred">üü† Far-red (660-800 nm)</option>
                        <option value="nir">üü£ NIR (&gt;800 nm)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Upload Mass Spec Data:</label>
                    <div class="file-upload">
                        <input type="file" id="fileInput" accept=".txt" multiple>
                        <label for="fileInput" class="file-upload-label">
                            üìÅ Upload files (ANY SIZE)<br>
                            <small>API-enabled processing</small>
                        </label>
                    </div>
                </div>
                
                <button class="btn" onclick="analyzeWithAPI()">üöÄ Analyze with Full API Access</button>
                
                <div class="deployment-options">
                    <h4>üåê Deployment Options to Fix API Issues</h4>
                    <div class="deployment-grid">
                        <div class="deployment-card">
                            <h5>üì± GitHub Pages</h5>
                            <p><strong>Free & Easy</strong></p>
                            <p>‚Ä¢ Upload HTML to GitHub repo</p>
                            <p>‚Ä¢ Enable GitHub Pages</p>
                            <p>‚Ä¢ Get https://username.github.io URL</p>
                        </div>
                        <div class="deployment-card">
                            <h5>‚ö° Netlify</h5>
                            <p><strong>Drag & Drop</strong></p>
                            <p>‚Ä¢ Visit netlify.com</p>
                            <p>‚Ä¢ Drag HTML file to deploy</p>
                            <p>‚Ä¢ Get instant HTTPS URL</p>
                        </div>
                        <div class="deployment-card">
                            <h5>üîß Local Server</h5>
                            <p><strong>Python:</strong> python -m http.server</p>
                            <p><strong>Node:</strong> npx serve .</p>
                            <p><strong>Live Server:</strong> VS Code extension</p>
                        </div>
                        <div class="deployment-card">
                            <h5>‚òÅÔ∏è Vercel</h5>
                            <p><strong>Professional</strong></p>
                            <p>‚Ä¢ Upload to vercel.com</p>
                            <p>‚Ä¢ Automatic HTTPS</p>
                            <p>‚Ä¢ Global CDN</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="results-panel">
                <div class="results-content" id="resultsContent">
                    <div class="status info">
                        <strong>üîç IndexedDB SecurityError Solutions:</strong>
                        <ol style="margin-top: 10px; margin-left: 20px;">
                            <li><strong>Quick Fix:</strong> Use a local web server instead of opening file directly</li>
                            <li><strong>GitHub Pages:</strong> Free hosting with full API access</li>
                            <li><strong>Netlify:</strong> Instant deployment with drag-and-drop</li>
                            <li><strong>Fallback Storage:</strong> In-memory processing for file:// protocol</li>
                            <li><strong>Web Workers:</strong> Background processing without IndexedDB</li>
                        </ol>
                    </div>
                    
                    <div class="fallback-storage">
                        <h4>üíæ Fallback Storage System</h4>
                        <p>When IndexedDB is unavailable, the analyzer automatically switches to:</p>
                        <ul style="margin-top: 10px; margin-left: 20px;">
                            <li><strong>In-Memory Storage:</strong> Processes data directly in RAM</li>
                            <li><strong>Chunked Processing:</strong> Handles large files in segments</li>
                            <li><strong>Progress Tracking:</strong> Real-time feedback without database</li>
                            <li><strong>Full Functionality:</strong> All features work without IndexedDB</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced API-enabled analyzer with fallback systems
        class APIEnabledAnalyzer {
            constructor() {
                this.hasIndexedDB = false;
                this.hasWebWorkers = false;
                this.storage = null;
                this.fallbackStorage = new Map(); // In-memory fallback
                this.chunkSize = 10000;
                this.checkAPIAvailability();
            }
            
            // Check what APIs are available
            async checkAPIAvailability() {
                const statusElement = document.getElementById('statusText');
                let statusHTML = '';
                
                // Check IndexedDB
                try {
                    if ('indexedDB' in window) {
                        // Try to actually open a database to test for security restrictions
                        const testDB = await new Promise((resolve, reject) => {
                            const request = indexedDB.open('test', 1);
                            request.onsuccess = () => {
                                request.result.close();
                                resolve(true);
                            };
                            request.onerror = () => reject(request.error);
                            request.onblocked = () => reject(new Error('blocked'));
                        });
                        
                        this.hasIndexedDB = true;
                        statusHTML += '‚úÖ IndexedDB: Available<br>';
                    } else {
                        statusHTML += '‚ùå IndexedDB: Not supported<br>';
                    }
                } catch (error) {
                    this.hasIndexedDB = false;
                    if (error.name === 'SecurityError') {
                        statusHTML += 'üîí IndexedDB: Blocked (file:// protocol)<br>';
                        statusHTML += 'üí° <strong>Solution:</strong> Deploy to web server for full API access<br>';
                    } else {
                        statusHTML += '‚ùå IndexedDB: Error - ' + error.message + '<br>';
                    }
                }
                
                // Check Web Workers
                try {
                    if ('Worker' in window) {
                        this.hasWebWorkers = true;
                        statusHTML += '‚úÖ Web Workers: Available<br>';
                    } else {
                        statusHTML += '‚ùå Web Workers: Not supported<br>';
                    }
                } catch (error) {
                    statusHTML += '‚ùå Web Workers: Error<br>';
                }
                
                // Check other APIs
                statusHTML += `‚úÖ File API: ${'File' in window ? 'Available' : 'Not available'}<br>`;
                statusHTML += `‚úÖ Blob API: ${'Blob' in window ? 'Available' : 'Not available'}<br>`;
                statusHTML += `‚úÖ URL API: ${'URL' in window ? 'Available' : 'Not available'}<br>`;
                
                // Overall status
                if (this.hasIndexedDB) {
                    statusHTML += '<br><strong style="color: #059669;">üéâ Full API access available!</strong>';
                } else {
                    statusHTML += '<br><strong style="color: #f59e0b;">‚ö†Ô∏è Limited API access - using fallback systems</strong>';
                }
                
                statusElement.innerHTML = statusHTML;
            }
            
            // Initialize storage (IndexedDB or fallback)
            async initStorage() {
                if (this.hasIndexedDB) {
                    try {
                        this.storage = await this.initIndexedDB();
                        console.log('‚úÖ IndexedDB storage initialized');
                        return 'indexeddb';
                    } catch (error) {
                        console.warn('IndexedDB init failed, using fallback:', error);
                    }
                }
                
                // Fallback to in-memory storage
                this.storage = this.fallbackStorage;
                console.log('‚úÖ Fallback in-memory storage initialized');
                return 'memory';
            }
            
            // Initialize IndexedDB
            async initIndexedDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('MSAnalyzerDB', 1);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('spectra')) {
                            const store = db.createObjectStore('spectra', { keyPath: 'id' });
                            store.createIndex('mz', 'mz', { unique: false });
                        }
                    };
                });
            }
            
            // Store data (IndexedDB or fallback)
            async storeData(data, fileId) {
                if (this.hasIndexedDB && this.storage instanceof IDBDatabase) {
                    return this.storeInIndexedDB(data, fileId);
                } else {
                    return this.storeInMemory(data, fileId);
                }
            }
            
            // Store in IndexedDB
            async storeInIndexedDB(data, fileId) {
                const transaction = this.storage.transaction(['spectra'], 'readwrite');
                const store = transaction.objectStore('spectra');
                
                for (let i = 0; i < data.length; i += this.chunkSize) {
                    const chunk = data.slice(i, i + this.chunkSize);
                    
                    for (const point of chunk) {
                        await new Promise((resolve, reject) => {
                            const request = store.add({
                                id: `${fileId}_${i}_${point.mz}`,
                                fileId: fileId,
                                mz: point.mz,
                                intensity: point.intensity
                            });
                            request.onsuccess = () => resolve();
                            request.onerror = () => resolve(); // Continue even if some fail
                        });
                    }
                    
                    // Yield control
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // Store in memory fallback
            async storeInMemory(data, fileId) {
                console.log(`Storing ${data.length} points in memory for ${fileId}`);
                this.fallbackStorage.set(fileId, data);
                
                // Simulate chunked processing for consistency
                for (let i = 0; i < data.length; i += this.chunkSize) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
            
            // Iterative peak detection (works with any storage)
            async findPeaks(data) {
                console.log('üîç Finding peaks...');
                const peaks = [];
                
                let maxIntensity = 0;
                for (const point of data) {
                    if (point.intensity > maxIntensity) {
                        maxIntensity = point.intensity;
                    }
                }
                
                const threshold = maxIntensity * 0.05;
                
                for (let i = 1; i < data.length - 1; i++) {
                    const prev = data[i - 1];
                    const current = data[i];
                    const next = data[i + 1];
                    
                    if (current.intensity > prev.intensity && 
                        current.intensity > next.intensity && 
                        current.intensity > threshold) {
                        
                        peaks.push({
                            index: i,
                            mz: current.mz,
                            intensity: current.intensity,
                            relativeIntensity: ((current.intensity / maxIntensity) * 100).toFixed(1)
                        });
                    }
                    
                    // Yield control periodically
                    if (i % this.chunkSize === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                peaks.sort((a, b) => b.intensity - a.intensity);
                return peaks.slice(0, 20);
            }
            
            // Charge state detection
            async detectChargeStates(peaks) {
                console.log('‚ö° Detecting charge states...');
                const chargeStates = [];
                
                const C13_SPACING = 1.003355;
                const AG_SPACING = 1.999655;
                const TOLERANCE = 0.01;
                
                for (let i = 0; i < peaks.length && i < 15; i++) {
                    for (let j = i + 1; j < peaks.length && j < i + 8; j++) {
                        const peak1 = peaks[i];
                        const peak2 = peaks[j];
                        const deltaHz = peak2.mz - peak1.mz;
                        
                        // Check C-13 spacing
                        const chargeFromC13 = C13_SPACING / deltaHz;
                        if (chargeFromC13 >= 1 && chargeFromC13 <= 15) {
                            const z = Math.round(chargeFromC13);
                            const theoreticalSpacing = C13_SPACING / z;
                            const error = Math.abs(deltaHz - theoreticalSpacing);
                            
                            if (error < TOLERANCE) {
                                chargeStates.push({
                                    peak1: peak1,
                                    peak2: peak2,
                                    deltaHz: deltaHz,
                                    chargeState: z,
                                    molecularMass: peak1.mz * z,
                                    error: error,
                                    isotopeType: 'C-13',
                                    confidence: 1 / (1 + error * 100)
                                });
                            }
                        }
                        
                        // Check Ag spacing
                        const chargeFromAg = AG_SPACING / deltaHz;
                        if (chargeFromAg >= 1 && chargeFromAg <= 15) {
                            const z = Math.round(chargeFromAg);
                            const theoreticalSpacing = AG_SPACING / z;
                            const error = Math.abs(deltaHz - theoreticalSpacing);
                            
                            if (error < TOLERANCE * 2) {
                                chargeStates.push({
                                    peak1: peak1,
                                    peak2: peak2,
                                    deltaHz: deltaHz,
                                    chargeState: z,
                                    molecularMass: peak1.mz * z,
                                    error: error,
                                    isotopeType: 'Ag',
                                    confidence: 1 / (1 + error * 100)
                                });
                            }
                        }
                    }
                    
                    // Yield control
                    if (i % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                chargeStates.sort((a, b) => b.confidence - a.confidence);
                return chargeStates;
            }
            
            // Calculate compositions
            calculateCompositions(chargeStates, dnaComposition, emissionColor) {
                const compositions = [];
                
                const colorPredictions = {
                    'green': 4, 'red': 6, 'fred': 8, 'nir': 10
                };
                const expectedN0 = colorPredictions[emissionColor] || 6;
                
                const isotopeData = {
                    H: 1.007825032, C: 12.0000000, N: 14.003074, 
                    O: 15.99491462, P: 30.973762, Ag: 106.905097, Cl: 34.96885269
                };
                
                const dnaBaseMass = dnaComposition.H * isotopeData.H +
                                 dnaComposition.C * isotopeData.C +
                                 dnaComposition.N * isotopeData.N +
                                 dnaComposition.O * isotopeData.O +
                                 dnaComposition.P * isotopeData.P;
                
                for (const cs of chargeStates.slice(0, 5)) {
                    const availableMass = cs.molecularMass - dnaBaseMass;
                    const estimatedTotalAg = Math.round(availableMass / isotopeData.Ag);
                    
                    let bestFit = null;
                    let bestError = Infinity;
                    
                    for (let totalAg = Math.max(8, estimatedTotalAg - 3); 
                         totalAg <= estimatedTotalAg + 3; totalAg++) {
                        
                        for (let N0 = Math.max(2, expectedN0 - 2); 
                             N0 <= Math.min(totalAg, expectedN0 + 2); N0++) {
                            
                            const Qcl = totalAg - N0;
                            
                            for (let nCl = 0; nCl <= 2; nCl++) {
                                const predictedMass = dnaBaseMass + 
                                                    totalAg * isotopeData.Ag + 
                                                    nCl * isotopeData.Cl;
                                
                                const predictedMz = (predictedMass - Qcl) / cs.chargeState;
                                const error = Math.abs(predictedMz - cs.peak1.mz);
                                
                                if (error < bestError && error < 2.0) {
                                    bestError = error;
                                    bestFit = {
                                        mz: cs.peak1.mz,
                                        intensity: cs.peak1.intensity,
                                        relativeIntensity: cs.peak1.relativeIntensity,
                                        chargeState: cs.chargeState,
                                        totalAg: totalAg,
                                        N0: N0,
                                        Qcl: Qcl,
                                        nCl: nCl,
                                        predictedMz: predictedMz,
                                        error: error,
                                        isotopeType: cs.isotopeType,
                                        confidence: cs.confidence
                                    };
                                }
                            }
                        }
                    }
                    
                    if (bestFit) {
                        compositions.push(bestFit);
                    }
                }
                
                return compositions;
            }
        }
        
        // Parse data file safely
        async function parseDataFile(text) {
            const lines = text.split('\n');
            const data = [];
            
            const chunkSize = 1000;
            for (let start = 0; start < lines.length; start += chunkSize) {
                const end = Math.min(start + chunkSize, lines.length);
                
                for (let i = start; i < end; i++) {
                    const line = lines[i].trim();
                    if (!line || line.startsWith('#')) continue;
                    
                    const parts = line.split(/[\s,\t]+/);
                    if (parts.length >= 2) {
                        const mz = parseFloat(parts[0]);
                        const intensity = parseFloat(parts[1]);
                        
                        if (!isNaN(mz) && !isNaN(intensity) && intensity >= 0) {
                            data.push({mz, intensity});
                        }
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 1));
            }
            
            data.sort((a, b) => a.mz - b.mz);
            return data;
        }
        
        // Calculate DNA composition
        function calculateDNAComposition(sequence, strands = 2) {
            let H = 0, C = 0, N = 0, O = 0, P = 0;
            
            const baseCompositions = {
                'A': {C: 5, H: 5, N: 5, O: 0},
                'T': {C: 5, H: 6, N: 2, O: 2},
                'G': {C: 5, H: 5, N: 5, O: 1},
                'C': {C: 4, H: 5, N: 3, O: 1}
            };
            
            for (let i = 0; i < sequence.length; i++) {
                const base = sequence[i].toUpperCase();
                if (baseCompositions[base]) {
                    C += baseCompositions[base].C;
                    H += baseCompositions[base].H;
                    N += baseCompositions[base].N;
                    O += baseCompositions[base].O;
                }
            }
            
            C += sequence.length * 5;
            H += sequence.length * 8;
            O += sequence.length;
            P += sequence.length - 1;
            O += (sequence.length - 1) * 4;
            H += 2;
            O += 2;
            
            return {
                H: H * strands, C: C * strands, N: N * strands, 
                O: O * strands, P: P * strands
            };
        }
        
        // Main analysis function with API detection
        async function analyzeWithAPI() {
            const resultsContent = document.getElementById('resultsContent');
            
            try {
                // Get inputs
                const dnaSequence = document.getElementById('dnaSequence').value.trim();
                const emissionColor = document.getElementById('emissionColor').value;
                const fileInput = document.getElementById('fileInput');
                
                if (!dnaSequence || !/^[ATGC]+$/i.test(dnaSequence)) {
                    throw new Error('Please enter a valid DNA sequence');
                }
                
                if (fileInput.files.length === 0) {
                    throw new Error('Please upload a data file');
                }
                
                // Initialize analyzer
                const analyzer = new APIEnabledAnalyzer();
                const storageType = await analyzer.initStorage();
                
                let html = `
                    <div class="status success">
                        ‚úÖ Analysis started with ${storageType === 'indexeddb' ? 'IndexedDB' : 'in-memory'} storage
                    </div>
                `;
                
                // Process file
                const file = fileInput.files[0];
                const text = await file.text();
                const data = await parseDataFile(text);
                
                html += `
                    <div class="status info">
                        üìä Loaded ${data.length} data points from ${file.name}<br>
                        Storage: ${storageType === 'indexeddb' ? 'üíæ IndexedDB' : 'üß† In-Memory'}<br>
                        m/z range: ${data[0].mz.toFixed(2)} - ${data[data.length-1].mz.toFixed(2)}
                    </div>
                `;
                resultsContent.innerHTML = html;
                
                // Store data
                await analyzer.storeData(data, file.name);
                
                // Find peaks
                const peaks = await analyzer.findPeaks(data);
                html += `
                    <div class="status info">
                        üéØ Found ${peaks.length} significant peaks
                    </div>
                `;
                resultsContent.innerHTML = html;
                
                // Detect charge states
                const chargeStates = await analyzer.detectChargeStates(peaks);
                
                if (chargeStates.length > 0) {
                    html += `
                        <div class="status success">
                            ‚ö° Detected ${chargeStates.length} isotopic patterns with charge states
                        </div>
                        <table class="data-table">
                            <tr>
                                <th>Peak 1 m/z</th>
                                <th>Peak 2 m/z</th>
                                <th>Œîm/z</th>
                                <th>Isotope</th>
                                <th>Charge z</th>
                                <th>Mass (Da)</th>
                                <th>Confidence</th>
                            </tr>
                    `;
                    
                    chargeStates.slice(0, 5).forEach(cs => {
                        html += `
                            <tr>
                                <td>${cs.peak1.mz.toFixed(4)}</td>
                                <td>${cs.peak2.mz.toFixed(4)}</td>
                                <td>${cs.deltaHz.toFixed(4)}</td>
                                <td>${cs.isotopeType}</td>
                                <td style="font-weight: bold; color: #4f46e5;">${cs.chargeState}</td>
                                <td>${cs.molecularMass.toFixed(1)}</td>
                                <td>${(cs.confidence * 100).toFixed(1)}%</td>
                            </tr>
                        `;
                    });
                    
                    html += '</table>';
                } else {
                    html += `
                        <div class="status warning">
                            ‚ö†Ô∏è No clear isotopic patterns detected
                        </div>
                    `;
                }
                
                // Calculate compositions
                const dnaComposition = calculateDNAComposition(dnaSequence, 2);
                const compositions = analyzer.calculateCompositions(chargeStates, dnaComposition, emissionColor);
                
                html += `
                    <div class="status success">
                        üß¨ DNA: C${dnaComposition.C}H${dnaComposition.H}N${dnaComposition.N}O${dnaComposition.O}P${dnaComposition.P}
                    </div>
                `;
                
                if (compositions.length > 0) {
                    html += `
                        <div class="status success">
                            üéØ Predicted ${compositions.length} cluster compositions
                        </div>
                        <table class="data-table">
                            <tr>
                                <th>m/z</th>
                                <th>z</th>
                                <th>Total Ag</th>
                                <th>N‚ÇÄ</th>
                                <th>Qcl</th>
                                <th>Error (Da)</th>
                            </tr>
                    `;
                    
                    compositions.forEach(comp => {
                        html += `
                            <tr>
                                <td>${comp.mz.toFixed(4)}</td>
                                <td style="font-weight: bold;">${comp.chargeState}</td>
                                <td style="color: #4f46e5; font-weight: bold;">${comp.totalAg}</td>
                                <td style="color: #059669; font-weight: bold;">${comp.N0}</td>
                                <td style="color: #dc2626; font-weight: bold;">${comp.Qcl}+</td>
                                <td>${comp.error.toFixed(4)}</td>
                            </tr>
                        `;
                    });
                    
                    html += '</table>';
                    
                    // Plot results
                    setTimeout(() => {
                        plotResults(data, peaks, chargeStates, compositions, file.name);
                    }, 100);
                }
                
                resultsContent.innerHTML = html;
                
            } catch (error) {
                console.error('Analysis error:', error);
                resultsContent.innerHTML = `
                    <div class="status error">
                        ‚ùå Error: ${error.message}
                    </div>
                `;
            }
        }
        
        // Plot results
        function plotResults(data, peaks, chargeStates, compositions, filename) {
            try {
                const plotDiv = document.createElement('div');
                plotDiv.className = 'plot-container';
                plotDiv.id = `api-plot-${Date.now()}`;
                document.getElementById('resultsContent').appendChild(plotDiv);
                
                const traces = [];
                
                // Sample data if too large
                const maxPlotPoints = 50000;
                let plotData = data;
                if (data.length > maxPlotPoints) {
                    const step = Math.ceil(data.length / maxPlotPoints);
                    plotData = [];
                    for (let i = 0; i < data.length; i += step) {
                        plotData.push(data[i]);
                    }
                }
                
                // Spectrum
                traces.push({
                    x: plotData.map(d => d.mz),
                    y: plotData.map(d => d.intensity),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Spectrum (${plotData.length} points)`,
                    line: {color: '#374151', width: 1}
                });
                
                // Peaks
                if (peaks.length > 0) {
                    traces.push({
                        x: peaks.slice(0, 15).map(p => p.mz),
                        y: peaks.slice(0, 15).map(p => p.intensity),
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Detected Peaks',
                        marker: {color: '#3b82f6', size: 8}
                    });
                }
                
                // Charge state pairs
                if (chargeStates.length > 0) {
                    const colors = ['#ef4444', '#10b981', '#f59e0b'];
                    chargeStates.slice(0, 3).forEach((cs, i) => {
                        traces.push({
                            x: [cs.peak1.mz, cs.peak2.mz],
                            y: [cs.peak1.intensity, cs.peak2.intensity],
                            type: 'scatter',
                            mode: 'markers+lines',
                            name: `${cs.isotopeType} z=${cs.chargeState}`,
                            marker: {color: colors[i], size: 12},
                            line: {color: colors[i], width: 3, dash: 'dot'}
                        });
                    });
                }
                
                // Compositions
                if (compositions.length > 0) {
                    traces.push({
                        x: compositions.map(c => c.mz),
                        y: compositions.map(c => c.intensity),
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Silver Clusters',
                        marker: {
                            color: '#10b981',
                            size: 15,
                            symbol: 'star'
                        }
                    });
                }
                
                const layout = {
                    title: `${filename} - API-Enabled Analysis`,
                    xaxis: {title: 'm/z'},
                    yaxis: {title: 'Intensity'},
                    showlegend: true,
                    height: 500
                };
                
                Plotly.newPlot(plotDiv.id, traces, layout, {responsive: true});
                
            } catch (plotError) {
                console.error('Plotting error:', plotError);
            }
        }
        
        // Initialize API check on load
        window.addEventListener('load', () => {
            new APIEnabledAnalyzer();
        });
        
        // File upload handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const label = document.querySelector('.file-upload-label');
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                const sizeMB = (file.size / 1024 / 1024).toFixed(1);
                label.innerHTML = `üìÅ ${file.name} (${sizeMB}MB)<br><small>Ready for API-enabled analysis</small>`;
            }
        });
    </script>
</body>
</html>
