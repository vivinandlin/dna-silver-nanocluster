<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA-Silver Cluster Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            padding: 30px;
        }
        
        .input-panel {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #e2e8f0;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }
        
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .file-upload {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }
        
        .file-upload input[type=file] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-upload-label {
            display: block;
            padding: 12px;
            background: #f1f5f9;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            text-align: center;
            color: #64748b;
        }
        
        .btn {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        
        .results-panel {
            background: white;
            border-radius: 15px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }
        
        .results-content {
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .status {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }
        
        .status.info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }
        
        .status.success {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #86efac;
        }
        
        .status.error {
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fca5a5;
        }
        
        .status.warning {
            background: #fef3c7;
            color: #d97706;
            border: 1px solid #fcd34d;
        }
        
        .plot-container {
            margin: 20px 0;
            height: 500px;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 12px;
        }
        
        .data-table th,
        .data-table td {
            padding: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }
        
        .data-table th {
            background: #f1f5f9;
            font-weight: 600;
        }
        
        .cluster-info {
            background: #f0f9ff;
            border: 2px solid #0369a1;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß¨ DNA-Silver Cluster Analyzer</h1>
            <p>Simple, robust isotope envelope analysis</p>
        </div>
        
        <div class="main-content">
            <div class="input-panel">
                <h3>üì• Cluster Analysis</h3>
                
                <div class="form-group">
                    <label for="dnaSequence">DNA Sequence:</label>
                    <textarea id="dnaSequence" rows="3" placeholder="CACCTAGCG">CACCTAGCG</textarea>
                </div>
                
                <div class="form-group">
                    <label for="emissionColor">Expected Emission:</label>
                    <select id="emissionColor">
                        <option value="green">üü¢ Green (N‚ÇÄ = 4)</option>
                        <option value="red" selected>üî¥ Red (N‚ÇÄ = 6)</option>
                        <option value="fred">üü† Far-red (N‚ÇÄ = 8)</option>
                        <option value="nir">üü£ NIR (N‚ÇÄ = 10-12)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Upload MS Data:</label>
                    <div class="file-upload">
                        <input type="file" id="fileInput" accept=".txt,.csv">
                        <label for="fileInput" class="file-upload-label">
                            üìÅ Upload spectrum<br>
                            <small>m/z intensity format</small>
                        </label>
                    </div>
                </div>
                
                <button class="btn" onclick="findClusters()">üîç Find Silver Clusters</button>
                
                <div class="cluster-info">
                    <h4>üéØ Cluster Detection</h4>
                    <p>This analyzer finds:</p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><strong>Isotope envelopes:</strong> Peaks ~1 Da apart</li>
                        <li><strong>Charge states:</strong> z = 3,4,5,6 from spacing</li>
                        <li><strong>Silver clusters:</strong> AgN compositions</li>
                        <li><strong>Fragment series:</strong> Loss of Ag‚Å∫</li>
                    </ul>
                </div>
            </div>
            
            <div class="results-panel">
                <div class="results-content" id="resultsContent">
                    <div class="status info">
                        <strong>üî¨ DNA-Silver Cluster Detection</strong><br><br>
                        Upload your ESI-MS data to detect silver nanoclusters with isotope envelope analysis.
                        <br><br>
                        <strong>Expected data format:</strong>
                        <ul style="margin-top: 10px; margin-left: 20px;">
                            <li>Two columns: m/z and intensity</li>
                            <li>Space, tab, or comma separated</li>
                            <li>Contains isotope envelopes (multiple peaks ~1 Da apart)</li>
                            <li>Multiple charge states of same clusters</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Third-party storage enabled cluster finder
        class StorageEnabledClusterFinder {
            constructor() {
                // Constants
                this.ISOTOPE_SPACING_TOLERANCE = 0.05;
                this.MIN_ENVELOPE_PEAKS = 3;
                this.EXPECTED_CHARGES = [3, 4, 5, 6, 7, 8];
                this.CHUNK_SIZE = 500; // Process in small chunks
                
                // Storage system
                this.hasIndexedDB = false;
                this.storage = new Map(); // Fallback storage
                this.dbName = 'ClusterAnalysisDB';
                this.dbVersion = 1;
                
                // Initialize storage
                this.initStorage();
                
                // Atomic masses
                this.MASSES = {
                    H: 1.007825, C: 12.000000, N: 14.003074,
                    O: 15.994915, P: 30.973762, Ag: 106.905097, Cl: 34.968853
                };
                
                // Color to N0 mapping
                this.COLOR_N0 = {
                    green: 4, red: 6, fred: 8, nir: 11
                };
            }
            
            // Initialize IndexedDB storage
            async initStorage() {
                try {
                    if (!('indexedDB' in window)) {
                        console.log('IndexedDB not supported, using memory storage');
                        return;
                    }
                    
                    await new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.dbVersion);
                        
                        request.onerror = () => {
                            console.log('IndexedDB failed, using memory storage');
                            resolve();
                        };
                        
                        request.onsuccess = () => {
                            this.hasIndexedDB = true;
                            console.log('‚úÖ IndexedDB initialized');
                            request.result.close();
                            resolve();
                        };
                        
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            
                            // Create object stores
                            if (!db.objectStoreNames.contains('peaks')) {
                                db.createObjectStore('peaks', { keyPath: 'id', autoIncrement: true });
                            }
                            if (!db.objectStoreNames.contains('envelopes')) {
                                db.createObjectStore('envelopes', { keyPath: 'id', autoIncrement: true });
                            }
                            if (!db.objectStoreNames.contains('clusters')) {
                                db.createObjectStore('clusters', { keyPath: 'id', autoIncrement: true });
                            }
                        };
                    });
                } catch (error) {
                    console.log('IndexedDB initialization failed:', error);
                }
            }
            
            // Store data in IndexedDB or fallback
            async storeData(storeName, data, chunkKey = 'default') {
                if (this.hasIndexedDB) {
                    return this.storeInIndexedDB(storeName, data, chunkKey);
                } else {
                    return this.storeInMemory(storeName, data, chunkKey);
                }
            }
            
            // Store in IndexedDB with chunked processing
            async storeInIndexedDB(storeName, data, chunkKey) {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.dbVersion);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    const transaction = db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    
                    // Clear existing data for this key
                    await new Promise((resolve) => {
                        const clearRequest = store.clear();
                        clearRequest.onsuccess = () => resolve();
                        clearRequest.onerror = () => resolve(); // Continue even if clear fails
                    });
                    
                    // Store data in chunks
                    const chunks = [];
                    for (let i = 0; i < data.length; i += this.CHUNK_SIZE) {
                        chunks.push(data.slice(i, i + this.CHUNK_SIZE));
                    }
                    
                    for (let i = 0; i < chunks.length; i++) {
                        await new Promise((resolve) => {
                            const request = store.add({
                                chunkKey: chunkKey,
                                chunkIndex: i,
                                data: chunks[i]
                            });
                            request.onsuccess = () => resolve();
                            request.onerror = () => resolve(); // Continue even if some chunks fail
                        });
                    }
                    
                    db.close();
                    console.log(`‚úÖ Stored ${data.length} items in IndexedDB (${chunks.length} chunks)`);
                    
                } catch (error) {
                    console.log('IndexedDB storage failed, using memory fallback:', error);
                    return this.storeInMemory(storeName, data, chunkKey);
                }
            }
            
            // Memory fallback storage
            async storeInMemory(storeName, data, chunkKey) {
                const key = `${storeName}_${chunkKey}`;
                this.storage.set(key, data);
                
                // Yield control for large datasets
                if (data.length > 1000) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                console.log(`‚úÖ Stored ${data.length} items in memory`);
            }
            
            // Retrieve data from storage
            async retrieveData(storeName, chunkKey = 'default') {
                if (this.hasIndexedDB) {
                    return this.retrieveFromIndexedDB(storeName, chunkKey);
                } else {
                    return this.retrieveFromMemory(storeName, chunkKey);
                }
            }
            
            // Retrieve from IndexedDB
            async retrieveFromIndexedDB(storeName, chunkKey) {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.dbVersion);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    const transaction = db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    
                    const chunks = await new Promise((resolve) => {
                        const request = store.getAll();
                        request.onsuccess = () => {
                            const allData = request.result;
                            const filteredChunks = allData
                                .filter(item => item.chunkKey === chunkKey)
                                .sort((a, b) => a.chunkIndex - b.chunkIndex);
                            resolve(filteredChunks);
                        };
                        request.onerror = () => resolve([]);
                    });
                    
                    db.close();
                    
                    // Reconstruct data from chunks
                    const data = [];
                    for (const chunk of chunks) {
                        data.push(...chunk.data);
                    }
                    
                    return data;
                    
                } catch (error) {
                    console.log('IndexedDB retrieval failed, using memory fallback:', error);
                    return this.retrieveFromMemory(storeName, chunkKey);
                }
            }
            
            // Retrieve from memory
            async retrieveFromMemory(storeName, chunkKey) {
                const key = `${storeName}_${chunkKey}`;
                return this.storage.get(key) || [];
            }
            
            // Find peaks with storage support
            async findPeaks(data) {
                const maxIntensity = Math.max(...data.map(d => d.intensity));
                const threshold = maxIntensity * 0.03;
                
                const peaks = [];
                
                // Process in chunks to avoid stack overflow
                for (let i = 0; i < data.length; i += this.CHUNK_SIZE) {
                    const chunk = data.slice(i, i + this.CHUNK_SIZE);
                    
                    for (const point of chunk) {
                        if (point.intensity > threshold) {
                            peaks.push(point);
                        }
                    }
                    
                    // Yield control every chunk
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
                
                // Store peaks for later use
                await this.storeData('peaks', peaks, 'filtered');
                
                return peaks;
            }
            
            // Find envelopes with chunked processing
            async findEnvelopes(peaks) {
                const envelopes = [];
                const used = new Set();
                
                // Process peaks in chunks to avoid stack overflow
                for (let chunkStart = 0; chunkStart < peaks.length; chunkStart += this.CHUNK_SIZE) {
                    const chunkEnd = Math.min(chunkStart + this.CHUNK_SIZE, peaks.length);
                    
                    for (let i = chunkStart; i < chunkEnd; i++) {
                        if (used.has(i)) continue;
                        
                        const envelope = [peaks[i]];
                        used.add(i);
                        
                        // Look for related peaks (limit search range to avoid stack overflow)
                        const searchEnd = Math.min(i + 100, peaks.length); // Limit search range
                        
                        for (let j = i + 1; j < searchEnd; j++) {
                            if (used.has(j)) continue;
                            
                            const deltaM = peaks[j].mz - peaks[i].mz;
                            if (deltaM > 5) break; // Too far away
                            
                            // Simple envelope check
                            let isPartOfEnvelope = false;
                            for (const envPeak of envelope) {
                                const spacing = Math.abs(peaks[j].mz - envPeak.mz);
                                const expectedSpacing = Math.round(spacing);
                                
                                if (Math.abs(spacing - expectedSpacing) < this.ISOTOPE_SPACING_TOLERANCE) {
                                    isPartOfEnvelope = true;
                                    break;
                                }
                            }
                            
                            if (isPartOfEnvelope) {
                                envelope.push(peaks[j]);
                                used.add(j);
                            }
                        }
                        
                        if (envelope.length >= this.MIN_ENVELOPE_PEAKS) {
                            envelope.sort((a, b) => a.mz - b.mz);
                            const analyzedEnvelope = this.analyzeEnvelope(envelope);
                            if (analyzedEnvelope) {
                                envelopes.push(analyzedEnvelope);
                            }
                        }
                    }
                    
                    // Yield control between chunks
                    await new Promise(resolve => setTimeout(resolve, 2));
                }
                
                // Store envelopes
                await this.storeData('envelopes', envelopes, 'detected');
                
                return envelopes;
            }
            
            // Analyze individual envelope
            analyzeEnvelope(peaks) {
                if (peaks.length < 3) return null;
                
                // Calculate average spacing between consecutive peaks
                const spacings = [];
                for (let i = 0; i < peaks.length - 1; i++) {
                    spacings.push(peaks[i + 1].mz - peaks[i].mz);
                }
                
                const avgSpacing = spacings.reduce((a, b) => a + b, 0) / spacings.length;
                
                // Determine charge state
                let bestCharge = 0;
                let bestError = Infinity;
                
                for (const z of this.EXPECTED_CHARGES) {
                    const expectedSpacing = 1.0 / z;
                    const error = Math.abs(avgSpacing - expectedSpacing);
                    
                    if (error < bestError) {
                        bestError = error;
                        bestCharge = z;
                    }
                }
                
                // Validate charge assignment
                const expectedSpacing = 1.0 / bestCharge;
                if (Math.abs(avgSpacing - expectedSpacing) > 0.1) {
                    return null; // Poor charge assignment
                }
                
                // Calculate centroid
                let totalIntensity = 0;
                let weightedMz = 0;
                
                for (const peak of peaks) {
                    totalIntensity += peak.intensity;
                    weightedMz += peak.mz * peak.intensity;
                }
                
                const centroid = weightedMz / totalIntensity;
                const molecularMass = centroid * bestCharge;
                
                return {
                    peaks: peaks,
                    centroid: centroid,
                    charge: bestCharge,
                    mass: molecularMass,
                    peakCount: peaks.length,
                    spacing: avgSpacing,
                    maxIntensity: Math.max(...peaks.map(p => p.intensity))
                };
            }
            
            // Match envelopes to clusters with chunked processing
            async matchClusters(envelopes, dnaSeq, expectedColor) {
                const clusters = [];
                const dnaComp = this.calculateDNA(dnaSeq);
                const dnaBaseMass = this.calculateMass(dnaComp);
                const expectedN0 = this.COLOR_N0[expectedColor] || 6;
                
                // Process envelopes in small chunks
                for (let envIndex = 0; envIndex < envelopes.length; envIndex++) {
                    const env = envelopes[envIndex];
                    const silverMass = env.mass - dnaBaseMass;
                    const estimatedAg = Math.round(silverMass / this.MASSES.Ag);
                    
                    if (estimatedAg < 5 || estimatedAg > 25) continue;
                    
                    let testCount = 0;
                    
                    // Limit the search space to prevent stack overflow
                    const agRange = Math.min(3, estimatedAg - 5); // Smaller range
                    
                    for (let nAg = Math.max(5, estimatedAg - agRange); 
                         nAg <= Math.min(25, estimatedAg + agRange); nAg++) {
                        
                        for (let N0 = 2; N0 <= Math.min(nAg, 12); N0 += 2) {
                            const Qcl = nAg - N0;
                            
                            const maxCl = Math.min(4, Qcl); // Limit chloride range
                            
                            for (let nCl = 0; nCl <= maxCl; nCl++) {
                                const predictedMass = dnaBaseMass + 
                                                    nAg * this.MASSES.Ag + 
                                                    nCl * this.MASSES.Cl;
                                
                                const error = Math.abs(predictedMass - env.mass);
                                const ppmError = (error / env.mass) * 1e6;
                                
                                if (ppmError < 100) {
                                    clusters.push({
                                        envelope: env,
                                        nAg: nAg,
                                        N0: N0,
                                        Qcl: Qcl,
                                        nCl: nCl,
                                        predictedMass: predictedMass,
                                        ppmError: ppmError,
                                        matchesExpected: N0 === expectedN0,
                                        formula: this.makeFormula(dnaComp, nAg, nCl)
                                    });
                                }
                                
                                testCount++;
                                
                                // Yield control every 20 tests
                                if (testCount % 20 === 0) {
                                    await new Promise(resolve => setTimeout(resolve, 1));
                                }
                            }
                        }
                    }
                    
                    // Yield control between envelopes
                    if (envIndex % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 5));
                    }
                }
                
                // Store clusters
                await this.storeData('clusters', clusters, 'matched');
                
                // Sort by mass accuracy
                clusters.sort((a, b) => a.ppmError - b.ppmError);
                return clusters;
            }
            
            // Calculate DNA composition
            calculateDNA(sequence) {
                const bases = {
                    A: {C:5, H:5, N:5, O:0}, T: {C:5, H:6, N:2, O:2},
                    G: {C:5, H:5, N:5, O:1}, C: {C:4, H:5, N:3, O:1}
                };
                
                let comp = {H:0, C:0, N:0, O:0, P:0};
                
                // Count bases
                for (const base of sequence.toUpperCase()) {
                    if (bases[base]) {
                        comp.C += bases[base].C;
                        comp.H += bases[base].H;
                        comp.N += bases[base].N;
                        comp.O += bases[base].O;
                    }
                }
                
                // Add backbone (2 strands)
                const n = sequence.length;
                comp.C += n * 10; // 2 * 5 carbons per sugar
                comp.H += n * 16; // 2 * 8 hydrogens per sugar
                comp.O += n * 2;  // 2 * 1 oxygen per sugar
                comp.P += (n-1) * 2; // 2 * (n-1) phosphates
                comp.O += (n-1) * 8; // 2 * 4 oxygens per phosphate
                comp.H += (n-1) * 2; // 2 * 1 hydrogen per phosphate
                comp.H += 4; // Terminal OH groups
                comp.O += 4;
                
                return comp;
            }
            
            // Calculate molecular mass
            calculateMass(composition) {
                return composition.H * this.MASSES.H +
                       composition.C * this.MASSES.C +
                       composition.N * this.MASSES.N +
                       composition.O * this.MASSES.O +
                       composition.P * this.MASSES.P;
            }
            
            // Make molecular formula string
            makeFormula(dna, nAg, nCl) {
                const parts = [];
                if (dna.C) parts.push(`C${dna.C}`);
                if (dna.H) parts.push(`H${dna.H}`);
                if (dna.N) parts.push(`N${dna.N}`);
                if (dna.O) parts.push(`O${dna.O}`);
                if (dna.P) parts.push(`P${dna.P}`);
                if (nAg) parts.push(`Ag${nAg}`);
                if (nCl) parts.push(`Cl${nCl}`);
                return parts.join('');
            }
        }
        
        // Simple data parser with chunked processing
        async function parseData(text) {
            const lines = text.split('\n');
            const data = [];
            const chunkSize = 1000;
            
            for (let start = 0; start < lines.length; start += chunkSize) {
                const end = Math.min(start + chunkSize, lines.length);
                
                for (let i = start; i < end; i++) {
                    const trimmed = lines[i].trim();
                    if (!trimmed || trimmed.startsWith('#')) continue;
                    
                    const parts = trimmed.split(/[\s,\t]+/);
                    if (parts.length >= 2) {
                        const mz = parseFloat(parts[0]);
                        const intensity = parseFloat(parts[1]);
                        
                        if (!isNaN(mz) && !isNaN(intensity) && intensity > 0) {
                            data.push({mz, intensity});
                        }
                    }
                }
                
                // Yield control between chunks
                await new Promise(resolve => setTimeout(resolve, 1));
            }
            
            return data.sort((a, b) => a.mz - b.mz);
        }
        
        // Main analysis function with storage support
        async function findClusters() {
            const resultsDiv = document.getElementById('resultsContent');
            
            try {
                // Get inputs
                const dnaSeq = document.getElementById('dnaSequence').value.trim();
                const color = document.getElementById('emissionColor').value;
                const fileInput = document.getElementById('fileInput');
                
                if (!dnaSeq || !/^[ATGC]+$/i.test(dnaSeq)) {
                    throw new Error('Enter valid DNA sequence (A,T,G,C only)');
                }
                
                if (!fileInput.files[0]) {
                    throw new Error('Upload MS data file');
                }
                
                resultsDiv.innerHTML = '<div class="status info">üîç Initializing storage and parsing data...</div>';
                
                // Initialize cluster finder with storage
                const finder = new StorageEnabledClusterFinder();
                
                // Wait for storage initialization
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Parse data with chunked processing
                const file = fileInput.files[0];
                const text = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
                
                resultsDiv.innerHTML = '<div class="status info">üìä Parsing data in chunks...</div>';
                const data = await parseData(text);
                
                if (data.length === 0) {
                    throw new Error('No valid data found in file');
                }
                
                // Process with progress updates
                resultsDiv.innerHTML = '<div class="status info">üéØ Finding peaks with storage support...</div>';
                const peaks = await finder.findPeaks(data);
                
                resultsDiv.innerHTML = '<div class="status info">üì¶ Detecting isotope envelopes...</div>';
                const envelopes = await finder.findEnvelopes(peaks);
                
                resultsDiv.innerHTML = '<div class="status info">üî¨ Matching silver clusters...</div>';
                const clusters = await finder.matchClusters(envelopes, dnaSeq, color);
                
                // Display results
                displayResults(data, peaks, envelopes, clusters, file.name, dnaSeq, color);
                
            } catch (error) {
                console.error('Analysis error:', error);
                resultsDiv.innerHTML = `<div class="status error">‚ùå ${error.message}</div>`;
            }
        }
        
        // Display results
        function displayResults(data, peaks, envelopes, clusters, filename, dnaSeq, color) {
            const resultsDiv = document.getElementById('resultsContent');
            
            let html = `
                <div class="status success">
                    ‚úÖ Analysis complete for ${filename}
                </div>
                <div class="status info">
                    üìä Found ${peaks.length} peaks ‚Üí ${envelopes.length} envelopes ‚Üí ${clusters.length} clusters<br>
                    üß¨ DNA: ${dnaSeq} (expected ${color} emission)
                </div>
            `;
            
            if (envelopes.length > 0) {
                html += `
                    <h4>üéØ Isotope Envelopes</h4>
                    <table class="data-table">
                        <tr><th>Centroid m/z</th><th>Charge</th><th>Mass (Da)</th><th>Peaks</th><th>Spacing</th></tr>
                `;
                
                envelopes.slice(0, 10).forEach(env => {
                    html += `
                        <tr>
                            <td>${env.centroid.toFixed(4)}</td>
                            <td>${env.charge}‚àí</td>
                            <td>${env.mass.toFixed(1)}</td>
                            <td>${env.peakCount}</td>
                            <td>${env.spacing.toFixed(4)}</td>
                        </tr>
                    `;
                });
                
                html += '</table>';
            }
            
            if (clusters.length > 0) {
                html += `
                    <h4>ü•à Silver Clusters</h4>
                    <table class="data-table">
                        <tr><th>m/z</th><th>z</th><th>AgN</th><th>N‚ÇÄ</th><th>Qcl</th><th>nCl</th><th>ppm</th><th>Match?</th></tr>
                `;
                
                clusters.slice(0, 15).forEach(cluster => {
                    const match = cluster.matchesExpected ? '‚úÖ' : '‚ö™';
                    const bg = cluster.matchesExpected ? '#f0fdf4' : 'white';
                    
                    html += `
                        <tr style="background: ${bg}">
                            <td>${cluster.envelope.centroid.toFixed(4)}</td>
                            <td>${cluster.envelope.charge}‚àí</td>
                            <td style="font-weight:bold;color:#4f46e5">${cluster.nAg}</td>
                            <td style="font-weight:bold;color:#059669">${cluster.N0}</td>
                            <td style="color:#dc2626">${cluster.Qcl}</td>
                            <td>${cluster.nCl}</td>
                            <td>${cluster.ppmError.toFixed(1)}</td>
                            <td>${match}</td>
                        </tr>
                    `;
                });
                
                html += '</table>';
                
                html += `
                    <div class="status info">
                        <strong>üî¨ Cluster Summary:</strong><br>
                        ‚Ä¢ Found ${clusters.filter(c => c.matchesExpected).length} clusters matching expected N‚ÇÄ<br>
                        ‚Ä¢ Charge states: ${[...new Set(envelopes.map(e => e.charge))].join(', ')}<br>
                        ‚Ä¢ AgN range: ${Math.min(...clusters.map(c => c.nAg))} - ${Math.max(...clusters.map(c => c.nAg))}<br>
                        ‚Ä¢ Best accuracy: ${Math.min(...clusters.map(c => c.ppmError)).toFixed(1)} ppm
                    </div>
                `;
            } else {
                html += '<div class="status warning">‚ö†Ô∏è No silver clusters found matching criteria</div>';
            }
            
            resultsDiv.innerHTML = html;
            
            // Plot if we have results
            if (envelopes.length > 0) {
                setTimeout(() => plotResults(data, envelopes, clusters, filename), 100);
            }
        }
        
        // Simple plotting
        function plotResults(data, envelopes, clusters, filename) {
            try {
                const plotDiv = document.createElement('div');
                plotDiv.className = 'plot-container';
                plotDiv.id = 'cluster-plot';
                document.getElementById('resultsContent').appendChild(plotDiv);
                
                // Downsample large datasets
                let plotData = data;
                if (data.length > 3000) {
                    const step = Math.ceil(data.length / 3000);
                    plotData = data.filter((_, i) => i % step === 0);
                }
                
                const traces = [{
                    x: plotData.map(d => d.mz),
                    y: plotData.map(d => d.intensity),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Spectrum',
                    line: {color: '#374151', width: 1}
                }];
                
                // Add envelope centroids
                if (envelopes.length > 0) {
                    traces.push({
                        x: envelopes.map(e => e.centroid),
                        y: envelopes.map(e => e.maxIntensity),
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Envelopes',
                        marker: {color: '#6366f1', size: 8}
                    });
                }
                
                // Add matched clusters
                if (clusters.length > 0) {
                    const matched = clusters.filter(c => c.matchesExpected);
                    if (matched.length > 0) {
                        traces.push({
                            x: matched.map(c => c.envelope.centroid),
                            y: matched.map(c => c.envelope.maxIntensity),
                            type: 'scatter',
                            mode: 'markers',
                            name: 'Expected Clusters',
                            marker: {color: '#10b981', size: 12, symbol: 'star'}
                        });
                    }
                }
                
                Plotly.newPlot('cluster-plot', traces, {
                    title: `${filename} - Silver Cluster Analysis`,
                    xaxis: {title: 'm/z'},
                    yaxis: {title: 'Intensity'},
                    height: 400
                }, {responsive: true});
                
            } catch (error) {
                console.error('Plot error:', error);
            }
        }
        
        // File upload handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const label = document.querySelector('.file-upload-label');
            if (e.target.files[0]) {
                const file = e.target.files[0];
                const sizeMB = (file.size / 1024 / 1024).toFixed(1);
                label.innerHTML = `üìÅ ${file.name} (${sizeMB}MB)<br><small>Ready for analysis</small>`;
            }
        });
    </script>
</body>
</html>
