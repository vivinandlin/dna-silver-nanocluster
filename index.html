<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA-Silver Nanocluster MS Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.27.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            padding: 30px;
        }
        
        .input-panel {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #e2e8f0;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }
        
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
        }
        
        .file-upload {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }
        
        .file-upload input[type=file] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-upload-label {
            display: block;
            padding: 12px;
            background: #f1f5f9;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            text-align: center;
            color: #64748b;
        }
        
        .btn {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
        }
        
        .results-panel {
            background: white;
            border-radius: 15px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }
        
        .results-content {
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .status {
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 500;
        }
        
        .status.info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }
        
        .status.success {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #86efac;
        }
        
        .status.error {
            background: #fee2e2;
            color: #dc2626;
            border: 1px solid #fca5a5;
        }
        
        .status.warning {
            background: #fef3c7;
            color: #d97706;
            border: 1px solid #fcd34d;
        }
        
        .plot-container {
            margin: 20px 0;
            height: 500px;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 12px;
        }
        
        .data-table th,
        .data-table td {
            padding: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }
        
        .data-table th {
            background: #f1f5f9;
            font-weight: 600;
        }
        
        .envelope-analysis {
            background: #f0f9ff;
            border: 2px solid #0369a1;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß¨ DNA-Silver Nanocluster MS Analyzer</h1>
            <p>Isotope envelope and charge state analysis for ESI-MS data</p>
        </div>
        
        <div class="main-content">
            <div class="input-panel">
                <h3>üì• MS Data Analysis</h3>
                
                <div class="form-group">
                    <label for="dnaSequence">DNA Sequence:</label>
                    <textarea id="dnaSequence" rows="3" placeholder="Enter DNA sequence (e.g., CACCTAGCGA)">CACCTAGCGA</textarea>
                </div>
                
                <div class="form-group">
                    <label for="emissionColor">Expected Emission:</label>
                    <select id="emissionColor">
                        <option value="green">üü¢ Green (N‚ÇÄ = 4)</option>
                        <option value="red" selected>üî¥ Red (N‚ÇÄ = 6)</option>
                        <option value="fred">üü† Far-red (N‚ÇÄ = 8)</option>
                        <option value="nir">üü£ NIR (N‚ÇÄ = 10-12)</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="massAccuracy">Mass Accuracy (ppm):</label>
                    <input type="number" id="massAccuracy" value="50" min="1" max="1000" placeholder="50">
                </div>
                
                <div class="form-group">
                    <label>Upload ESI-MS Data:</label>
                    <div class="file-upload">
                        <input type="file" id="fileInput" accept=".txt,.csv" multiple>
                        <label for="fileInput" class="file-upload-label">
                            üìÅ Upload mass spectrum<br>
                            <small>Two columns: m/z, intensity</small>
                        </label>
                    </div>
                </div>
                
                <button class="btn" onclick="analyzeIsotopeEnvelopes()">üî¨ Analyze Isotope Envelopes</button>
                
                <div class="envelope-analysis">
                    <h4>üß™ Analysis Method</h4>
                    <p><strong>Isotope Envelope Analysis:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><strong>Find envelopes:</strong> Groups of peaks ~1 Da apart</li>
                        <li><strong>Determine charge:</strong> From isotope spacing (1/z)</li>
                        <li><strong>Calculate mass:</strong> Centroid m/z √ó charge state</li>
                        <li><strong>Match compositions:</strong> DNA + AgN + Cl ligands</li>
                        <li><strong>Validate fragments:</strong> Loss of Ag‚Å∫ from parent</li>
                    </ul>
                </div>
            </div>
            
            <div class="results-panel">
                <div class="results-content" id="resultsContent">
                    <div class="status info">
                        <strong>üî¨ Isotope Envelope Analysis for DNA-Ag Nanoclusters</strong><br><br>
                        This analyzer is designed for ESI-MS data showing:
                        <ul style="margin-top: 10px; margin-left: 20px;">
                            <li><strong>Isotope envelopes:</strong> Multiple peaks ~1 Da apart</li>
                            <li><strong>Multiple charge states:</strong> Same species at z=3,4,5,6</li>
                            <li><strong>Fragmentation series:</strong> Loss of Ag‚Å∫ (NAg = 10,11,12...18)</li>
                            <li><strong>Accurate mass assignment:</strong> Based on envelope centroids</li>
                        </ul>
                        <br>
                        <strong>Upload your ESI-MS data to begin analysis.</strong>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced MS Analyzer with chunked processing and storage management
        class IsotopeEnvelopeAnalyzer {
            constructor() {
                this.massAccuracy = 50; // ppm
                this.chunkSize = 1000; // Process data in chunks
                this.storage = new Map(); // In-memory storage
                this.hasIndexedDB = false;
                this.hasWebWorkers = false;
                
                // Check API availability
                this.checkAPIAvailability();
                
                // Isotope data
                this.isotopeData = {
                    H: 1.007825032, C: 12.0000000, N: 14.003074, 
                    O: 15.99491462, P: 30.973762, 
                    Ag: 106.905097, Cl: 34.96885269
                };
                
                // Expected charge states for DNA-Ag clusters
                this.expectedChargeStates = [3, 4, 5, 6, 7, 8];
            }
            
            // Check what APIs are available
            async checkAPIAvailability() {
                try {
                    if ('indexedDB' in window) {
                        const testDB = await new Promise((resolve, reject) => {
                            const request = indexedDB.open('test', 1);
                            request.onsuccess = () => {
                                request.result.close();
                                resolve(true);
                            };
                            request.onerror = () => reject(request.error);
                            request.onblocked = () => reject(new Error('blocked'));
                        });
                        this.hasIndexedDB = true;
                        console.log('‚úÖ IndexedDB available');
                    }
                } catch (error) {
                    this.hasIndexedDB = false;
                    console.log('‚ö†Ô∏è IndexedDB not available, using fallback storage');
                }
                
                this.hasWebWorkers = 'Worker' in window;
                console.log(`‚úÖ Web Workers: ${this.hasWebWorkers ? 'Available' : 'Not available'}`);
            }
            
            // Store data with chunked processing
            async storeData(data, key) {
                if (this.hasIndexedDB) {
                    return this.storeInIndexedDB(data, key);
                } else {
                    return this.storeInMemory(data, key);
                }
            }
            
            // Store in IndexedDB with chunked processing
            async storeInIndexedDB(data, key) {
                try {
                    const db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('MSAnalyzerDB', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const database = event.target.result;
                            if (!database.objectStoreNames.contains('spectra')) {
                                database.createObjectStore('spectra', { keyPath: 'id' });
                            }
                        };
                    });
                    
                    // Store in chunks to avoid stack overflow
                    const transaction = db.transaction(['spectra'], 'readwrite');
                    const store = transaction.objectStore('spectra');
                    
                    for (let i = 0; i < data.length; i += this.chunkSize) {
                        const chunk = data.slice(i, i + this.chunkSize);
                        
                        await new Promise((resolve, reject) => {
                            const request = store.put({
                                id: `${key}_chunk_${i}`,
                                data: chunk,
                                chunkIndex: i
                            });
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        
                        // Yield control to prevent stack overflow
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                    
                    db.close();
                    console.log(`‚úÖ Stored ${data.length} points in IndexedDB`);
                } catch (error) {
                    console.warn('IndexedDB storage failed, using fallback:', error);
                    return this.storeInMemory(data, key);
                }
            }
            
            // Fallback in-memory storage
            async storeInMemory(data, key) {
                this.storage.set(key, data);
                
                // Simulate chunked processing for consistency
                for (let i = 0; i < data.length; i += this.chunkSize) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
                
                console.log(`‚úÖ Stored ${data.length} points in memory`);
            }
            
            // Find isotope envelopes with chunked processing
            async findIsotopeEnvelopes(data) {
                console.log('üîç Finding isotope envelopes with chunked processing...');
                
                // Store data first
                await this.storeData(data, 'spectrum_data');
                
                const envelopes = [];
                const threshold = this.getThreshold(data);
                
                // Process data in chunks to avoid stack overflow
                let currentGroup = [];
                let processedPoints = 0;
                
                for (let chunkStart = 0; chunkStart < data.length; chunkStart += this.chunkSize) {
                    const chunkEnd = Math.min(chunkStart + this.chunkSize, data.length);
                    const chunk = data.slice(chunkStart, chunkEnd);
                    
                    for (let i = 0; i < chunk.length - 1; i++) {
                        const current = chunk[i];
                        const next = i < chunk.length - 1 ? chunk[i + 1] : 
                                   (chunkEnd < data.length ? data[chunkEnd] : null);
                        
                        // Skip low intensity peaks
                        if (current.intensity < threshold) continue;
                        
                        currentGroup.push(current);
                        processedPoints++;
                        
                        // Check if this is end of envelope
                        if (!next || (next.mz - current.mz > 2.0)) {
                            if (currentGroup.length >= 3) {
                                const envelope = await this.analyzeEnvelopeAsync(currentGroup);
                                if (envelope) {
                                    envelopes.push(envelope);
                                }
                            }
                            currentGroup = [];
                        }
                        
                        // Yield control every 100 points
                        if (processedPoints % 100 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                    
                    // Yield control between chunks
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
                
                // Handle final group
                if (currentGroup.length >= 3) {
                    const envelope = await this.analyzeEnvelopeAsync(currentGroup);
                    if (envelope) {
                        envelopes.push(envelope);
                    }
                }
                
                console.log(`Found ${envelopes.length} isotope envelopes`);
                return envelopes;
            }
            
            // Async envelope analysis to prevent stack overflow
            async analyzeEnvelopeAsync(peaks) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(this.analyzeEnvelope(peaks));
                    }, 0);
                });
            }
            
            // Analyze individual envelope to determine charge state and mass
            analyzeEnvelope(peaks) {
                if (peaks.length < 3) return null;
                
                // Calculate average spacing between consecutive peaks
                let totalSpacing = 0;
                let spacingCount = 0;
                
                for (let i = 0; i < peaks.length - 1; i++) {
                    const spacing = peaks[i + 1].mz - peaks[i].mz;
                    if (spacing > 0.5 && spacing < 2.0) { // Reasonable isotope spacing
                        totalSpacing += spacing;
                        spacingCount++;
                    }
                }
                
                if (spacingCount === 0) return null;
                
                const avgSpacing = totalSpacing / spacingCount;
                
                // Determine charge state: 1/avgSpacing should be integer
                let bestChargeState = 0;
                let bestError = Infinity;
                
                for (const z of this.expectedChargeStates) {
                    const expectedSpacing = 1.0 / z;
                    const error = Math.abs(avgSpacing - expectedSpacing);
                    
                    if (error < bestError) {
                        bestError = error;
                        bestChargeState = z;
                    }
                }
                
                // Validate charge state assignment
                const expectedSpacing = 1.0 / bestChargeState;
                const spacingError = Math.abs(avgSpacing - expectedSpacing) / expectedSpacing;
                
                if (spacingError > 0.1) { // >10% error, probably not correct
                    return null;
                }
                
                // Calculate centroid and molecular mass
                const centroid = this.calculateCentroid(peaks);
                const molecularMass = centroid * bestChargeState;
                
                return {
                    peaks: peaks,
                    chargeState: bestChargeState,
                    centroidMz: centroid,
                    molecularMass: molecularMass,
                    peakCount: peaks.length,
                    avgSpacing: avgSpacing,
                    spacingError: spacingError,
                    maxIntensity: Math.max(...peaks.map(p => p.intensity))
                };
            }
            
            // Calculate intensity-weighted centroid of envelope
            calculateCentroid(peaks) {
                let totalIntensity = 0;
                let weightedMz = 0;
                
                for (const peak of peaks) {
                    totalIntensity += peak.intensity;
                    weightedMz += peak.mz * peak.intensity;
                }
                
                return weightedMz / totalIntensity;
            }
            
            // Get intensity threshold (5% of base peak)
            getThreshold(data) {
                const maxIntensity = Math.max(...data.map(d => d.intensity));
                return maxIntensity * 0.05;
            }
            
            // Match envelopes to compositions with chunked processing
            async matchCompositions(envelopes, dnaComposition, emissionColor) {
                console.log('üßÆ Matching compositions with chunked processing...');
                const compositions = [];
                
                // Color predictions
                const colorPredictions = {
                    'green': { N0: 4, range: [2, 6] },
                    'red': { N0: 6, range: [4, 8] },
                    'fred': { N0: 8, range: [6, 10] },
                    'nir': { N0: 11, range: [10, 12] }
                };
                
                const colorInfo = colorPredictions[emissionColor] || { N0: 6, range: [4, 8] };
                const dnaBaseMass = this.calculateDNAMass(dnaComposition);
                
                // Process envelopes in chunks
                for (let envIndex = 0; envIndex < envelopes.length; envIndex++) {
                    const envelope = envelopes[envIndex];
                    const availableMass = envelope.molecularMass - dnaBaseMass;
                    const estimatedTotalAg = Math.round(availableMass / this.isotopeData.Ag);
                    
                    if (estimatedTotalAg < 5 || estimatedTotalAg > 25) continue;
                    
                    let bestMatch = null;
                    let bestError = Infinity;
                    let testCount = 0;
                    
                    // Chunked composition testing
                    for (let totalAg = Math.max(5, estimatedTotalAg - 3); 
                         totalAg <= Math.min(25, estimatedTotalAg + 3); totalAg++) {
                        
                        for (let N0 = Math.max(0, colorInfo.range[0]); 
                             N0 <= Math.min(totalAg, colorInfo.range[1]); N0 += 2) {
                            
                            const Qcl = totalAg - N0;
                            
                            for (let nCl = 0; nCl <= Math.min(8, Qcl); nCl++) {
                                const predictedMass = dnaBaseMass + 
                                                    totalAg * this.isotopeData.Ag + 
                                                    nCl * this.isotopeData.Cl;
                                
                                const massError = Math.abs(predictedMass - envelope.molecularMass);
                                const ppmError = (massError / envelope.molecularMass) * 1e6;
                                
                                if (ppmError < this.massAccuracy && ppmError < bestError) {
                                    bestError = ppmError;
                                    bestMatch = {
                                        envelope: envelope,
                                        totalAg: totalAg,
                                        N0: N0,
                                        Qcl: Qcl,
                                        nCl: nCl,
                                        predictedMass: predictedMass,
                                        massError: massError,
                                        ppmError: ppmError,
                                        matchesExpected: N0 === colorInfo.N0,
                                        molecularFormula: this.generateFormula(dnaComposition, totalAg, nCl)
                                    };
                                }
                                
                                testCount++;
                                
                                // Yield control every 50 tests
                                if (testCount % 50 === 0) {
                                    await new Promise(resolve => setTimeout(resolve, 1));
                                }
                            }
                        }
                    }
                    
                    if (bestMatch) {
                        compositions.push(bestMatch);
                    }
                    
                    // Yield control between envelopes
                    await new Promise(resolve => setTimeout(resolve, 2));
                }
                
                // Sort by mass accuracy
                compositions.sort((a, b) => a.ppmError - b.ppmError);
                
                console.log(`Matched ${compositions.length} compositions`);
                return compositions;
            }
            
            // Calculate DNA molecular mass
            calculateDNAMass(dnaComp) {
                return dnaComp.H * this.isotopeData.H +
                       dnaComp.C * this.isotopeData.C +
                       dnaComp.N * this.isotopeData.N +
                       dnaComp.O * this.isotopeData.O +
                       dnaComp.P * this.isotopeData.P;
            }
            
            // Generate molecular formula
            generateFormula(dnaComp, nAg, nCl) {
                const parts = [];
                if (dnaComp.C > 0) parts.push(`C${dnaComp.C}`);
                if (dnaComp.H > 0) parts.push(`H${dnaComp.H}`);
                if (dnaComp.N > 0) parts.push(`N${dnaComp.N}`);
                if (dnaComp.O > 0) parts.push(`O${dnaComp.O}`);
                if (dnaComp.P > 0) parts.push(`P${dnaComp.P}`);
                if (nAg > 0) parts.push(`Ag${nAg}`);
                if (nCl > 0) parts.push(`Cl${nCl}`);
                return parts.join('');
            }
        }
        
        // Parse MS data file with chunked processing
        async function parseDataFile(text) {
            const lines = text.split('\n');
            const data = [];
            const chunkSize = 1000;
            
            for (let start = 0; start < lines.length; start += chunkSize) {
                const end = Math.min(start + chunkSize, lines.length);
                
                for (let i = start; i < end; i++) {
                    const trimmed = lines[i].trim();
                    if (!trimmed || trimmed.startsWith('#')) continue;
                    
                    const parts = trimmed.split(/[\s,\t]+/);
                    if (parts.length >= 2) {
                        const mz = parseFloat(parts[0]);
                        const intensity = parseFloat(parts[1]);
                        
                        if (!isNaN(mz) && !isNaN(intensity) && intensity > 0) {
                            data.push({mz, intensity});
                        }
                    }
                }
                
                // Yield control between chunks
                await new Promise(resolve => setTimeout(resolve, 1));
            }
            
            data.sort((a, b) => a.mz - b.mz);
            return data;
        }
        
        // Calculate DNA composition
        function calculateDNAComposition(sequence, strands = 2) {
            let H = 0, C = 0, N = 0, O = 0, P = 0;
            
            const baseCompositions = {
                'A': {C: 5, H: 5, N: 5, O: 0},
                'T': {C: 5, H: 6, N: 2, O: 2},
                'G': {C: 5, H: 5, N: 5, O: 1},
                'C': {C: 4, H: 5, N: 3, O: 1}
            };
            
            // Count bases
            for (const base of sequence.toUpperCase()) {
                if (baseCompositions[base]) {
                    C += baseCompositions[base].C;
                    H += baseCompositions[base].H;
                    N += baseCompositions[base].N;
                    O += baseCompositions[base].O;
                }
            }
            
            // Add backbone
            const numBases = sequence.length;
            C += numBases * 5; // ribose
            H += numBases * 8;
            O += numBases * 1;
            P += numBases - 1; // phosphodiester
            O += (numBases - 1) * 4;
            H += numBases - 1;
            H += 2; // terminal OH
            O += 2;
            
            return {
                H: H * strands, C: C * strands, N: N * strands, 
                O: O * strands, P: P * strands
            };
        }
        
        // Main analysis function
        async function analyzeIsotopeEnvelopes() {
            const resultsContent = document.getElementById('resultsContent');
            
            try {
                const dnaSequence = document.getElementById('dnaSequence').value.trim();
                const emissionColor = document.getElementById('emissionColor').value;
                const massAccuracy = parseFloat(document.getElementById('massAccuracy').value);
                const fileInput = document.getElementById('fileInput');
                
                if (!dnaSequence || !/^[ATGC]+$/i.test(dnaSequence)) {
                    throw new Error('Please enter a valid DNA sequence');
                }
                
                if (fileInput.files.length === 0) {
                    throw new Error('Please upload MS data file');
                }
                
                // Initialize analyzer
                const analyzer = new IsotopeEnvelopeAnalyzer();
                analyzer.massAccuracy = massAccuracy;
                
                let html = `
                    <div class="status success">
                        ‚úÖ Starting isotope envelope analysis
                    </div>
                `;
                resultsContent.innerHTML = html;
                
                // Parse data
                const file = fileInput.files[0];
                const text = await file.text();
                const data = await parseDataFile(text);
                
                html += `
                    <div class="status info">
                        üìä Loaded ${data.length} data points<br>
                        m/z range: ${data[0].mz.toFixed(2)} - ${data[data.length-1].mz.toFixed(2)}<br>
                        Mass accuracy: ¬±${massAccuracy} ppm
                    </div>
                `;
                resultsContent.innerHTML = html;
                
                // Find isotope envelopes
                const envelopes = await analyzer.findIsotopeEnvelopes(data);
                
                if (envelopes.length > 0) {
                    html += `
                        <div class="status success">
                            üéØ Found ${envelopes.length} isotope envelopes
                        </div>
                        <table class="data-table">
                            <tr>
                                <th>Centroid m/z</th>
                                <th>Charge z</th>
                                <th>Molecular Mass</th>
                                <th>Peaks</th>
                                <th>Avg Spacing</th>
                                <th>Spacing Error</th>
                            </tr>
                    `;
                    
                    envelopes.forEach(env => {
                        html += `
                            <tr>
                                <td>${env.centroidMz.toFixed(4)}</td>
                                <td style="font-weight: bold; color: #4f46e5;">${env.chargeState}‚àí</td>
                                <td>${env.molecularMass.toFixed(1)}</td>
                                <td>${env.peakCount}</td>
                                <td>${env.avgSpacing.toFixed(4)}</td>
                                <td>${(env.spacingError * 100).toFixed(1)}%</td>
                            </tr>
                        `;
                    });
                    
                    html += '</table>';
                } else {
                    html += `
                        <div class="status warning">
                            ‚ö†Ô∏è No isotope envelopes detected. Check data quality or adjust parameters.
                        </div>
                    `;
                    resultsContent.innerHTML = html;
                    return;
                }
                
                // Match compositions with progress tracking
                const dnaComposition = calculateDNAComposition(dnaSequence, 2);
                
                html += `
                    <div class="status info">
                        üßÆ Matching compositions... (this may take a moment)
                    </div>
                `;
                resultsContent.innerHTML = html;
                
                const compositions = await analyzer.matchCompositions(envelopes, dnaComposition, emissionColor);
                
                html += `
                    <div class="status success">
                        üß¨ DNA: C${dnaComposition.C}H${dnaComposition.H}N${dnaComposition.N}O${dnaComposition.O}P${dnaComposition.P}
                    </div>
                `;
                
                if (compositions.length > 0) {
                    html += `
                        <div class="status success">
                            üéØ Matched ${compositions.length} compositions
                        </div>
                        <table class="data-table">
                            <tr>
                                <th>m/z (centroid)</th>
                                <th>z</th>
                                <th>NAg</th>
                                <th>N‚ÇÄ</th>
                                <th>Qcl</th>
                                <th>nCl</th>
                                <th>ppm Error</th>
                                <th>Expected?</th>
                                <th>Formula</th>
                            </tr>
                    `;
                    
                    compositions.forEach(comp => {
                        const expectedIcon = comp.matchesExpected ? '‚úÖ' : '‚ö™';
                        const bgColor = comp.matchesExpected ? '#f0fdf4' : 'white';
                        
                        html += `
                            <tr style="background-color: ${bgColor};">
                                <td>${comp.envelope.centroidMz.toFixed(4)}</td>
                                <td style="font-weight: bold;">${comp.envelope.chargeState}‚àí</td>
                                <td style="color: #4f46e5; font-weight: bold;">${comp.totalAg}</td>
                                <td style="color: #059669; font-weight: bold;">${comp.N0}</td>
                                <td style="color: #dc2626; font-weight: bold;">${comp.Qcl}</td>
                                <td>${comp.nCl}</td>
                                <td>${comp.ppmError.toFixed(1)}</td>
                                <td style="font-weight: bold;">${expectedIcon}</td>
                                <td style="font-size: 0.7em; font-family: monospace;">${comp.molecularFormula}</td>
                            </tr>
                        `;
                    });
                    
                    html += '</table>';
                    
                    html += `
                        <div class="status info">
                            <strong>üî¨ Analysis Summary:</strong><br>
                            ‚Ä¢ <strong>Isotope envelopes:</strong> Groups of peaks with 1/z spacing<br>
                            ‚Ä¢ <strong>Charge states:</strong> Determined from isotope spacing<br>
                            ‚Ä¢ <strong>Molecular masses:</strong> Centroid m/z √ó charge state<br>
                            ‚Ä¢ <strong>‚úÖ Expected N‚ÇÄ:</strong> Matches ${emissionColor} emission prediction<br>
                            ‚Ä¢ <strong>Mass accuracy:</strong> All matches within ${massAccuracy} ppm
                        </div>
                    `;
                    
                    // Plot results
                    setTimeout(() => {
                        plotEnvelopeAnalysis(data, envelopes, compositions, file.name);
                    }, 100);
                } else {
                    html += `
                        <div class="status warning">
                            ‚ö†Ô∏è No compositions matched within ${massAccuracy} ppm mass accuracy
                        </div>
                    `;
                }
                
                resultsContent.innerHTML = html;
                
            } catch (error) {
                console.error('Analysis error:', error);
                resultsContent.innerHTML = `
                    <div class="status error">
                        ‚ùå Error: ${error.message}
                    </div>
                `;
            }
        }
        
        // Plot envelope analysis results with memory management
        function plotEnvelopeAnalysis(data, envelopes, compositions, filename) {
            try {
                const plotDiv = document.createElement('div');
                plotDiv.className = 'plot-container';
                plotDiv.id = `envelope-plot-${Date.now()}`;
                document.getElementById('resultsContent').appendChild(plotDiv);
                
                const traces = [];
                
                // Aggressively sample large datasets to prevent memory issues
                const maxPlotPoints = 5000; // Reduced from 20000
                let plotData = data;
                if (data.length > maxPlotPoints) {
                    const step = Math.ceil(data.length / maxPlotPoints);
                    plotData = [];
                    for (let i = 0; i < data.length; i += step) {
                        plotData.push(data[i]);
                    }
                    console.log(`Downsampled spectrum: ${data.length} ‚Üí ${plotData.length} points`);
                }
                
                // Full spectrum
                traces.push({
                    x: plotData.map(d => d.mz),
                    y: plotData.map(d => d.intensity),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'MS Spectrum',
                    line: {color: '#374151', width: 1}
                });
                
                // Envelope centroids (limit to top 20)
                if (envelopes.length > 0) {
                    const topEnvelopes = envelopes.slice(0, 20);
                    traces.push({
                        x: topEnvelopes.map(e => e.centroidMz),
                        y: topEnvelopes.map(e => e.maxIntensity),
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Envelope Centroids',
                        marker: {color: '#6b7280', size: 10, symbol: 'diamond'}
                    });
                }
                
                // Matched compositions (limit to top 15)
                if (compositions.length > 0) {
                    const topCompositions = compositions.slice(0, 15);
                    const expectedComps = topCompositions.filter(c => c.matchesExpected);
                    const otherComps = topCompositions.filter(c => !c.matchesExpected);
                    
                    if (expectedComps.length > 0) {
                        traces.push({
                            x: expectedComps.map(c => c.envelope.centroidMz),
                            y: expectedComps.map(c => c.envelope.maxIntensity),
                            type: 'scatter',
                            mode: 'markers',
                            name: 'Expected N‚ÇÄ',
                            marker: {color: '#10b981', size: 15, symbol: 'star'}
                        });
                    }
                    
                    if (otherComps.length > 0) {
                        traces.push({
                            x: otherComps.map(c => c.envelope.centroidMz),
                            y: otherComps.map(c => c.envelope.maxIntensity),
                            type: 'scatter',
                            mode: 'markers',
                            name: 'Other Matches',
                            marker: {color: '#3b82f6', size: 12, symbol: 'circle'}
                        });
                    }
                }
                
                const layout = {
                    title: `${filename} - Isotope Envelope Analysis`,
                    xaxis: {title: 'm/z'},
                    yaxis: {title: 'Intensity'},
                    showlegend: true,
                    height: 500
                };
                
                // Use configuration to optimize performance
                const config = {
                    responsive: true,
                    displayModeBar: true,
                    displaylogo: false,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d']
                };
                
                Plotly.newPlot(plotDiv.id, traces, layout, config);
                
            } catch (plotError) {
                console.error('Plotting error:', plotError);
                // Fallback: create simple text summary if plotting fails
                const plotDiv = document.createElement('div');
                plotDiv.innerHTML = `
                    <div class="status warning">
                        ‚ö†Ô∏è Plotting failed due to memory constraints. 
                        Analysis completed successfully with ${envelopes.length} envelopes 
                        and ${compositions.length} matched compositions.
                    </div>
                `;
                document.getElementById('resultsContent').appendChild(plotDiv);
            }
        }
        
        // File upload handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const label = document.querySelector('.file-upload-label');
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                const sizeMB = (file.size / 1024 / 1024).toFixed(1);
                label.innerHTML = `üìÅ ${file.name} (${sizeMB}MB)<br><small>Ready for envelope analysis</small>`;
            }
        });
    </script>
</body>
</html>
